= Ordering Search Results

== Ordering Search Results

In this section we'll learn how to use the Pearson Similarity algorithm to recommend reviews based on user similarity.

[source,cypher]
----
CALL algo.similarity.cosine(
  "// Fill in this part of the query
   RETURN id(u) AS item, id(business) AS id, review.stars AS weight",
  {graph: "cypher", similarityCutoff:0.5, degreeCutoff:3, write:true, topK:10,
   skipValue: algo.NaN(), params: {city: "Phoenix"}})
YIELD nodes, similarityPairs, min, max, mean, stdDev, p90, p95, p99
RETURN *
----

And here's the answer:

[source,cypher]
----
CALL algo.similarity.cosine(
  "MATCH (u:User:Phoenix)
   WITH u LIMIT 50000
   MATCH (u)-[:WROTE]->(review:Review)-[:REVIEWS]->(business:Business)
   RETURN id(u) AS item, id(business) AS id, review.stars AS weight",
  {graph: "cypher", similarityCutoff:0.5, degreeCutoff:3, write:true, topK:10, skipValue: algo.NaN())
YIELD nodes, similarityPairs, min, max, mean, stdDev, p90, p95, p99
RETURN *
----

We want to use this similarity graph to improve the reviews that we show on our application.
We can find similar users by following the `SIMILAR` relationship from a user:

[source,cypher]
----
MATCH (me:User {id: $userId})-[similarity:SIMILAR]-(other)
RETURN other, similarity.score AS similarity
ORDER BY similarity DESC
----

Now let's update the application to use this new information.
Instead of selecting the reviews for our businesses based on the opinions of users unrelated to `user-name`, we'll show reviews written by similar users.
