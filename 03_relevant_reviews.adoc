= Finding relevant reviews

== Finding relevant reviews

We want to return relevant businesses in search results based not only on the search term, but also the user's context.
In this section we'll learn how to use the Personalized PageRank algorithm to do this.

== Answer: User <-> Business

This is what the query should look like:

[source, cypher]
----
:params userId => "7C4B2Skmh4X9f8xJDo9O4w";

MATCH (u:User {id: $userId})-[:FRIENDS]->(other)
WITH collect(other) AS others
UNWIND others as other
MATCH (other)-[:WROTE]->()-[:REVIEWS]->(business)
WITH collect(distinct business) AS businesses, others
WITH others + businesses AS sourceNodes

CALL algo.pageRank.stream(
  'MATCH (u:User) RETURN id(u) AS id UNION MATCH (b:Business) RETURN id(b) AS id',
  'MATCH (u:User)-[:WROTE]->(review)-[:REVIEWS]->(business)
   RETURN id(u) AS source, id(business) AS target',
  {iterations:20, dampingFactor:0.85, direction: "BOTH", sourceNodes: sourceNodes}
)
YIELD nodeId, score
WITH algo.getNodeById(nodeId) AS node, score WHERE node:Business

RETURN node.name AS page,score
ORDER BY score DESC
LIMIT 10
----


[source,cypher]
----
CALL algo.pageRank.stream(
  'MATCH (u:User) RETURN id(u) AS id',
  'MATCH (u:User)-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(u2)
   RETURN id(u) AS source, id(u2) AS target, count(*) AS weight',
  {iterations:20, dampingFactor:0.85, direction: "BOTH", graph: "cypher"}
)
YIELD nodeId, score
WITH algo.getNodeById(nodeId) AS node, score

RETURN node.name AS page,score
ORDER BY score DESC
LIMIT 10
----

[source,cypher]
----
CALL algo.pageRank.stream(
  'MATCH (u:User) RETURN id(u) AS id',
  'MATCH (u:User)-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(u2)
   RETURN id(u) AS source, id(u2) AS target, count(*) AS weight',
  {iterations:20, dampingFactor:0.85, direction: "BOTH", graph: "cypher"}
)
YIELD nodeId, score
WITH algo.getNodeById(nodeId) AS node, score

RETURN node.name AS page,score
ORDER BY score DESC
LIMIT 10
----

[source, cypher]
----
:params userId => "k70TsLeGBYSXsnr5q-cXg";
:params userId => "Lk70TsLeGBYSXsnr5q-cXg";

MATCH (u:User {id: $userId})-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(other)
WITH other, count(*) AS count
WHERE count > 1
WITH collect(other) AS sourceNodes

CALL algo.pageRank.stream(
  'MATCH (u:User) RETURN id(u) AS id',
  'MATCH (u:User)-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(u2)
   RETURN id(u) AS source, id(u2) AS target, count(*) AS weight',
  {iterations:20, dampingFactor:0.85, direction: "BOTH", graph: "cypher", sourceNodes: sourceNodes}
)
YIELD nodeId, score
WITH algo.getNodeById(nodeId) AS node, score

RETURN node.name AS page,score
ORDER BY score DESC
LIMIT 10
----

We'll pre-load the in memory graph using the following query:

[source, cypher]
----
CALL algo.graph.load('review-graph',
  'MATCH (u:User) RETURN id(u) AS id',
  'MATCH (u:User)-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(u2)
   RETURN id(u) AS source, id(u2) AS target, count(*) AS weight',
  {graph:'cypher', direction: "BOTH"});
----

And now we'll execute the Personalized PageRank algorithm:

[source,cypher]
----
// Compute source nodes
MATCH (u:User {id: $userId})-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(other)
WITH u, other, count(*) AS count
WHERE count > 1
WITH u, collect(other) AS sourceNodes

// Execute the PageRank algorithm
CALL algo.pageRank.stream(null, null, {
  iterations:5, dampingFactor:0.85, direction: "BOTH",
  graph: "review-graph", sourceNodes: sourceNodes
})

// Only keep users that have a PageRank score bigger than the default
YIELD nodeId, score
WITH u, algo.getNodeById(nodeId) AS node, score
WHERE score > 0.15 AND node <> u

// Keep up to 50 users
WITH u, node, score
ORDER BY score DESC
LIMIT 50

// Create a relationship between our user and the influential users
MERGE (u)-[trust:TRUSTS]->(node)
SET trust.score = score
----

Now we can find the other users that our user trusts by executing the following query:

[source,cypher]
----
match (u:User {id: $userId})-[trusts:TRUSTS]->(other)
RETURN other.name, other.id, trusts.score AS score
ORDER BY score DESC
----
