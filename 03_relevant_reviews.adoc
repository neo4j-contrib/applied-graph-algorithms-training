= Finding relevant reviews

== Finding relevant reviews

We want to return relevant reviews for a business based on the user's context.
In this section we'll learn how to use the Personalized PageRank algorithm to do this.

== Pre-load reviews graph

We'll pre-load the in memory graph using the following query as we want to run the algorithm multiple times for different users:

[source, cypher]
----
CALL algo.graph.load('review-graph',
  'MATCH (u:User) RETURN id(u) AS id',
  'MATCH (u:User)-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(u2)
   RETURN id(u) AS source, id(u2) AS target, count(*) AS weight',
  {graph:'cypher', direction: "BOTH"});
----

[source, cypher]
----
:params userId => "Lk70TsLeGBYSXsnr5q-cXg";
----

== Answer: User <-> Business

This is what the answer should look like:

[source,cypher]
----
// Compute source nodes
MATCH (u:User {id: $userId})-[:WROTE]->()-[:REVIEWS]->()<-[:REVIEWS]-()<-[:WROTE]-(other)
WITH u, other, count(*) AS count
WHERE count > 1
WITH u, collect(other) AS sourceNodes

// Execute the PageRank algorithm
CALL algo.pageRank.stream(null, null, {
  iterations:5, dampingFactor:0.85, direction: "BOTH",
  graph: "review-graph", sourceNodes: sourceNodes
})

// Only keep users that have a PageRank score bigger than the default
YIELD nodeId, score
WITH u, algo.getNodeById(nodeId) AS node, score
WHERE score > 0.15 AND node <> u

// Keep up to 50 users
WITH u, node, score
ORDER BY score DESC
LIMIT 50

// Create a relationship between our user and the influential users
MERGE (u)-[trust:TRUSTS]->(node)
SET trust.score = score
----

== Find trusted users

Now we can find the other users that our user trusts by executing the following query:

[source,cypher]
----
match (u:User {id: $userId})-[trusts:TRUSTS]->(other)
RETURN other.name, other.id, trusts.score AS score
ORDER BY score DESC
----

== Using the trust score

We can then use it like this:

[source, cypher]
----
:params businessId => "jzM4dTlstNmGDPRT9SC6Hw";
:params userId => "Lk70TsLeGBYSXsnr5q-cXg";


MATCH (b:Business {id: $businessId})
MATCH (user:User {id: $userId})
OPTIONAL MATCH (b)<-[:REVIEWS]-(r:Review)<-[:WROTE]-(u:User)
OPTIONAL MATCH (u)<-[trusts:TRUSTS]-(user)
WITH r{.text, stars: toFloat(r.stars), name: u.name, date: toString(r.date), trustScore: trusts.score} AS review
ORDER BY trusts.score, r.date DESC LIMIT 1000
RETURN COLLECT(review) AS reviews
----
